/**********
Daniel Couch
Numerical Computing Main Program
Option for interface or computation.
**********/

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <mpi.h>
#include "interface.h"
#include "computation.h"

#define DEBUG TRUE
#define INVALID_OPTION -1
#define VALUE_CHANGED -5
#define INTERFACE_OPTION 100
#define COMPUTATION_OPTION 200

int parse_arguments(int argc, char *argv[], char *data_file_name, int *num_procs);

void usage(void){
    printf("\n\n numerical_computing.c \n USAGE: ./NC [option] -f [data file name] -n [number of processes]\n [option] is 'i' or 'c' \n 'i' opens the user inteface which can be used to generate a data file. \n 'c' performs compution based on other parameters. \n 'f' Provides the name of the file containing the data, generated by the interface.\n 'n' Provides number of processes to use for parallelization.\n\n");
}

// deal with arguments/options.
int parse_arguments(int argc, char *argv[], char *data_file_name, int *num_procs){
    int value_to_return = INVALID_OPTION;
    if (argc == 1) {
        printf("No arguments provided.\n\n");
        usage();
        return value_to_return;
    }
    char *option_type;
    int arg_found;
    int check = 0;
    // set this if there's an error.
    char *error_message = NULL;
    // first just look for the argument 'o' as that's what the other args depend on.
    if ((arg_found = getopt(argc, argv, "o:")) != -1) {
        option_type = optarg;
    }
    else{
        printf("No [option] found\n");
        usage();
        return value_to_return;
    }
    bool good_option = false;
    // set return value according to option.
    if (strcmp(option_type, "interface") == 0) {
        value_to_return = INTERFACE_OPTION;
        good_option = true;
    }
    if (strcmp(option_type, "computation") == 0) {
        value_to_return = COMPUTATION_OPTION;
        good_option = true;
    }
    if (!good_option) {
        printf("Option: %s is not a valid option.\n", option_type);
        return value_to_return;
    }
    // don't need to do anything else if it's just the interface.
    if (value_to_return == INTERFACE_OPTION) {
        return value_to_return;
    }
    // Computation option selected:
    bool procs_defined = false;
    if (value_to_return == COMPUTATION_OPTION) {
        while ((arg_found = getopt(argc, argv, "f:n:")) != -1) {
            switch (arg_found) {
                case 'f':
                    strcpy(data_file_name, optarg);
                    data_file_name = optarg;
                    break;
                case 'n':
                    ;
                    int inp = atoi(optarg);
                    *num_procs = inp;
                    procs_defined = true;
                    break;
                default:
                    break;
            }
        }
    }
    if (!procs_defined) {
        printf("Number of processes not defined. Defaulting to 4.\n");
        *num_procs = 4;
    }
    return value_to_return;
}

int main(int argc, char *argv[]){
    char *data_file_name = malloc(300);
    int num_procs;
    int option;
    option = parse_arguments(argc, argv, data_file_name, &num_procs);
    if (option == INVALID_OPTION) {
        return 0;
    }
    if (option == INTERFACE_OPTION) {
        //
	printf("Running interface.\n");
        user_interface();
        ;
    }
    if (option == COMPUTATION_OPTION) {
        // Pass control to computation program.
        int setup_finished = setup_computation(argc, argv, num_procs, data_file_name);
        ;
    }
    return 0;
}
